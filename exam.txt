-----------------------------------------------------------------------------------------------------------------------------------------                                                                                                                                                                      BT USING ARRAY
-----------------------------------------------------------------------------------------------------------------------------------------
//implementation of tree using array
#include <stdio.h>
#define S 20

int tree[S];
int i=0;

void set_root(){
if(tree[0]==0){
    printf("Enter data to the Root Node:");
    scanf("%d",&tree[0]);
}else{
    printf("Root Node already exists.\n");
}
}
void left_child(){
    int idx;
    printf("Enter index of parent Node for inserting left child:");
    scanf("%d",&idx);
    if(tree[idx]==0){
        printf("Parent not exists.");
    }else{
        printf("Enter data to left child of %d:",tree[idx]);
        scanf("%d",&tree[(2*idx+1)]);
    }
}
void right_child(){
    int idx;
    printf("Enter index of parent Node for inserting right child:");
    scanf("%d",&idx);
    if(tree[idx]==0){
        printf("Parent not exit.\n");
    }else{
        printf("Enter data to right child of %d:",tree[idx]);
        scanf("%d",&tree[(2*idx+2)]);
    }
}
void dis_tree(){
    for(int i=0; i<S; i++){
        if(tree[i]==0){
            printf("_ ");
        }else{
            printf("%d ",tree[i]);
        }
    }
    printf("\n");
}

int main(){
    int ch;
    set_root();

    while(1){

        printf("\n1.Left child\n2.Right child\n3.Display\n4.Exit\nEnter choice:");
        scanf("%d",&ch);

        switch(ch){
            case 1:left_child();
            break;
            case 2:right_child();
            break;
            case 3:dis_tree();
            break;
            case 4:
            break;
            default:printf("Invalid Input\n");
        }
        if(ch==4){
            break;
        }
    }

    printf("Inorder:");
    preorder();

    return 0;
}


----------------------------------------------------------------------------------------------------------------------------------------   
Binary Tree using linked list
-----------------------------------------------------------------------------------------------------------------------------------------
// implementation of tree using linked list
#include <stdio.h>
#include <stdlib.h>

struct node{
    char data;
    struct node *left;
    struct node *right;
};

struct node *create(){
    struct node *newnode;
    newnode = (struct node*)malloc(sizeof(struct node));
    char data;
    printf("Enter Data to the node (for no node enter 1) :");
    scanf(" %c",&data);
    if(data == '1'){
        return 0;
    }
    newnode->data = data;
    printf("Left node to the %c:\n",data);
    newnode->left = create();
    printf("Right node to the %c:\n",data);
    newnode->right =  create();
    return newnode;
}

void preorder(struct node *root){
    if(root == 0){
        return;
    }
    printf("%c ",root->data);
    preorder(root->left);
    preorder(root->right);
}

void inorder(struct node *root){
    if (root == 0){
        return;
    }
    inorder(root->left);
    printf("%c ",root->data);
    inorder(root->right);
}

void postorder(struct node *root){
    if(root == 0){
        return;
    }
    postorder(root->left);
    postorder(root->right);
    printf("%c ",root->data);
}

int main(){
    struct node *root;
    root = create();
    preorder(root);
    printf("\n");
     inorder(root);
    printf("\n");
   postorder(root);
    printf("\n");
    return 0; }


----------------------------------------------------------------------------------------------------------------------------------------- 
implement  recursive tree traversal (inorder, preorder and post order)
-----------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory allocation error!\n");
        return NULL;
    }
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}
struct Node* insertNode(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->data) {
        root->left = insertNode(root->left, value);
    } else if (value > root->data) {
        root->right = insertNode(root->right, value);
    }
    return root;
}
void inorderTraversal(struct Node* root) {
    if (root == NULL) {
        return;
    }
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}
void preorderTraversal(struct Node* root) {
    if (root == NULL) {
        return;
    }
    printf("%d ", root->data);
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}
void postorderTraversal(struct Node* root) {
    if (root == NULL) {
        return;
    }
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->data);
}
int main() {
    struct Node* root = NULL;
    int numNodes, value;

    printf("Enter the number of nodes to insert: ");
    scanf("%d", &numNodes);
    printf("Enter the values of the nodes:\n");
    for (int i = 0; i < numNodes; i++) {
        scanf("%d", &value);
        root = insertNode(root, value);
    }
    printf("Inorder traversal: ");
    inorderTraversal(root);
    printf("\n");

    printf("Preorder traversal: ");
    preorderTraversal(root);
    printf("\n");

    printf("Postorder traversal: ");
    postorderTraversal(root);
    printf("\n");

    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------
to demonstrate various tree operations (count number of nodes, leaf nodes, printing leaf nodes, height of tree, mirror image of the tree)
-----------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}
struct Node* insertNode(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->data) {
        root->left = insertNode(root->left, value);
    } else if (value > root->data) {
        root->right = insertNode(root->right, value);
    }
    return root;
}
int findHeight(struct Node* root) {
    if (root == NULL) {
        return -1;
    }
    int leftHeight = findHeight(root->left);
    int rightHeight = findHeight(root->right);
    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}
int countNodes(struct Node* root) {
    if (root == NULL) {
        return 0;
    }
    return 1 + countNodes(root->left) + countNodes(root->right);
}
int countLeafNodes(struct Node* root) {
    if (root == NULL) {
        return 0;
    }
    if (root->left == NULL && root->right == NULL) {
        return 1;
    }
    return countLeafNodes(root->left) + countLeafNodes(root->right);
}

struct Node* createMirror(struct Node* root) {
    if (root == NULL) {
        return NULL;
    }
    struct Node* temp = root->left;
    root->left = createMirror(root->right);
    root->right = createMirror(temp);
    return root;
}
void printLeafNodes(struct Node* root) {
    if (root == NULL) {
        return;
    }
    if (root->left == NULL && root->right == NULL) {
        printf("%d ", root->data);
    }
    printLeafNodes(root->left);
    printLeafNodes(root->right);
}

void printMirror(struct Node* root) {
    if (root != NULL) {
        printMirror(root->right);
        printf("%d ", root->data);
        printMirror(root->left);
    }
}
int main() {
    struct Node* root = NULL;
    int choice, value;
    do {
        printf("\n1. Insert Element\n");
        printf("2. Find Height\n");
        printf("3. Count Nodes\n");
        printf("4. Count Leaf Nodes\n");
        printf("5. Create Mirror Image\n");
        printf("6. Print Leaf Nodes\n");
        printf("0. Exit\n");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the value to insert: ");
                scanf("%d", &value);
                root = insertNode(root, value);
                break;
            case 2:
                printf("Height of the BST: %d\n", findHeight(root));
                break;
            case 3:
                printf("Number of nodes in the BST: %d\n", countNodes(root));
                break;
            case 4:
                printf("Number of leaf nodes in the BST: %d\n", countLeafNodes(root));
                break;
            case 5:
                root = createMirror(root);
                printf("Mirror Image created.\n");
                printMirror(root);
                break;
            case 6:
                printf("Leaf Nodes: ");
                printLeafNodes(root);
                printf("\n");
                break;
            case 0:
                printf("Exiting the program.\n");
                break;
            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }
    } while (choice != 0);
    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------
create Binary search tree, insertion and searching and all deletion cases in BST
-----------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node *right_child;
    struct node *left_child;
};

struct node* new_node(int x) {
    struct node *temp;
    temp = malloc(sizeof(struct node));
    temp->data = x;
    temp->left_child = NULL;
    temp->right_child = NULL;

    return temp;
}

struct node* search(struct node * root, int x) {
    if (root == NULL || root->data == x)
        return root;
    else if (x > root->data)
        return search(root->right_child, x);
    else
        return search(root->left_child, x);
}

struct node* insert(struct node * root, int x) {
    if (root == NULL)
        return new_node(x);
    else if (x > root->data)
        root->right_child = insert(root->right_child, x);
    else
        root -> left_child = insert(root->left_child, x);
    return root;
}

struct node* find_minimum(struct node * root) {
    if (root == NULL)
        return NULL;
    else if (root->left_child != NULL)
        return find_minimum(root->left_child);
    return root;
}

struct node* delete(struct node * root, int x) {
    if (root == NULL)
        return NULL;
    if (x > root->data)
        root->right_child = delete(root->right_child, x);
    else if (x < root->data)
        root->left_child = delete(root->left_child, x);
    else {
        if (root->left_child == NULL && root->right_child == NULL) {
            free(root);
            return NULL;
        }
        else if (root->left_child == NULL || root->right_child == NULL) {
            struct node *temp;
            if (root->left_child == NULL)
                temp = root->right_child;
            else
                temp = root->left_child;
            free(root);
            return temp;
        }
        else {
            struct node *temp = find_minimum(root->right_child);
            root->data = temp->data;
            root->right_child = delete(root->right_child, temp->data);
        }
    }
    return root;
}

void inorder(struct node *root) {
    if (root != NULL) {
        inorder(root->left_child);
        printf(" %d ", root->data);
        inorder(root->right_child);
    }
}

int main() {
    struct node *root = NULL;
    int choice, data, num_elements, i;

    while (1) {
        printf("\n1. Insert\n2. Delete\n3. Inorder Traversal\n4. Exit\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements to insert: ");
                scanf("%d", &num_elements);
                for (i = 0; i < num_elements; i++) {
                    printf("Enter element %d: ", i + 1);
                    scanf("%d", &data);
                    root = insert(root, data);
                }
                break;
            case 2:
                printf("Enter data to delete: ");
                scanf("%d", &data);
                root = delete(root, data);
                break;
            case 3:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------
implement non-recursive tree traversal (inorder, preorder and post order)
-----------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *left, *right;
} Node;

typedef struct Stack {
    Node **s;
    int top;
    int capacity;
} Stack;

void push(Stack *s, Node *t);
Node *pop(Stack *s);
int isEmpty(Stack *s);
void inorder(Node *root);
void preorder(Node *root);
void postorder(Node *root);
Node *createNode(int data);
Stack *createStack(int capacity);
void freeTree(Node *root);
void insertNode(Node **root, int data);

int main() {
    int choice, data;
    Node *root = NULL;

    do {
        printf("\nBinary Tree Operations\n");
        printf("1. Insert Node\n");
        printf("2. Inorder Traversal\n");
        printf("3. Preorder Traversal\n");
        printf("4. Postorder Traversal\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter data for the new node: ");
                scanf("%d", &data);
                insertNode(&root, data);
                break;
            case 2:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;
            case 3:
                printf("Preorder Traversal: ");
                preorder(root);
                printf("\n");
                break;
            case 4:
                printf("Postorder Traversal: ");
                postorder(root);
                printf("\n");
                break;
            case 5:
                printf("Exiting...\n");
                freeTree(root);
                break;
            default:
                printf("Invalid choice. Please enter a number between 1 and 5.\n");
        }
    } while (choice != 5);

    return 0;
}

void push(Stack *s, Node *t) {
    if (s->top == s->capacity - 1) {
        printf("Stack Overflow\n");
        return;
    }
    s->top++;
    s->s[s->top] = t;
}

Node *pop(Stack *s) {
    if (s->top == -1) {
        printf("Stack Underflow\n");
        return NULL;
    }
    Node *t = s->s[s->top];
    s->top--;
    return t;
}

int isEmpty(Stack *s) {
    return s->top == -1;
}

void inorder(Node *root) {
    if (root == NULL) return;

    Stack *s = createStack(100);
    Node *T = root;

    while (T != NULL || !isEmpty(s)) {
        while (T != NULL) {
            push(s, T);
            T = T->left;
        }

        T = pop(s);
        printf("%d ", T->data);
        T = T->right;
    }
}

void preorder(Node *root) {
    if (root == NULL) return;

    Stack *s = createStack(100);
    Node *T = root;

    while (T != NULL || !isEmpty(s)) {
        while (T != NULL) {
            printf("%d ", T->data);
            push(s, T);
            T = T->left;
        }

        T = pop(s);
        T = T->right;
    }
}

void postorder(Node *root) {
    if (root == NULL) return;

    Stack *s1 = createStack(100);
    Stack *s2 = createStack(100);
    push(s1, root);

    while (!isEmpty(s1)) {
        root = pop(s1);
        push(s2, root);
        if (root->left != NULL)
            push(s1, root->left);
        if (root->right != NULL)
            push(s1, root->right);
    }

    while (!isEmpty(s2)) {
        root = pop(s2);
        printf("%d ", root->data);
    }
}

Node *createNode(int data) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

Stack *createStack(int capacity) {
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    if (stack == NULL) {
        printf("Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    stack->s = (Node **)malloc(capacity * sizeof(Node *));
    if (stack->s == NULL) {
        printf("Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    stack->top = -1;
    stack->capacity = capacity;
    return stack;
}

void freeTree(Node *root) {
    if (root != NULL) {
        freeTree(root->left);
        freeTree(root->right);
        free(root);
    }
}

void insertNode(Node **root, int data) {
    Node *newNode = createNode(data);
    if (*root == NULL) {
        *root = newNode;
    } else {
        Node *current = *root;
        Node *parent = NULL;
        while (1) {
            parent = current;
            if (data < current->data) {
                current = current->left;
                if (current == NULL) {
                    parent->left = newNode;
                    return;
                }
            } else {
                current = current->right;
                if (current == NULL) {
                    parent->right = newNode;
                    return;
                }
            }
        }
    }
}


------------------------------------------------------------------------------------------------------------------------------------------
to check whether the tree is balanced or not and tree is AVL or not. Also your code should tell which rotation case is required if tree is imbalanced. show all rotations cases. input should be user choice
------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
    int height;
};

struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    if (!newNode) {
        printf("Memory allocation failed!\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1; 
    return newNode;
}

int getHeight(struct TreeNode* node) {
    if (node == NULL)
        return 0;
    return node->height;
}

struct TreeNode* rightRotate(struct TreeNode* y) {
    struct TreeNode* x = y->left;
    struct TreeNode* T2 = x->right;

    
    x->right = y;
    y->left = T2;

    
    y->height = 1 + (getHeight(y->left) > getHeight(y->right) ? getHeight(y->left) : getHeight(y->right));
    x->height = 1 + (getHeight(x->left) > getHeight(x->right) ? getHeight(x->left) : getHeight(x->right));

    return x;
}

struct TreeNode* leftRotate(struct TreeNode* x) {
    struct TreeNode* y = x->right;
    struct TreeNode* T2 = y->left;

    
    y->left = x;
    x->right = T2;

   
    x->height = 1 + (getHeight(x->left) > getHeight(x->right) ? getHeight(x->left) : getHeight(x->right));
    y->height = 1 + (getHeight(y->left) > getHeight(y->right) ? getHeight(y->left) : getHeight(y->right));

    return y;
}

int getBalanceFactor(struct TreeNode* node) {
    if (node == NULL)
        return 0;
    return getHeight(node->left) - getHeight(node->right);
}

struct TreeNode* insertNode(struct TreeNode* root, int data) {
    if (root == NULL)
        return createNode(data);

    if (data < root->data)
        root->left = insertNode(root->left, data);
    else if (data > root->data)
        root->right = insertNode(root->right, data);
    else
        return root; 

    
    root->height = 1 + (getHeight(root->left) > getHeight(root->right) ? getHeight(root->left) : getHeight(root->right));

    
    int balance = getBalanceFactor(root);

    
    if (balance > 1 && data < root->left->data)
        return rightRotate(root);

    
    if (balance < -1 && data > root->right->data)
        return leftRotate(root);

    
    if (balance > 1 && data > root->left->data) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    
    if (balance < -1 && data < root->right->data) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

int isBalanced(struct TreeNode* root) {
    if (root == NULL)
        return 1;

    int leftHeight = getHeight(root->left);
    int rightHeight = getHeight(root->right);

    if (abs(leftHeight - rightHeight) <= 1 && isBalanced(root->left) && isBalanced(root->right))
        return 1;

    return 0;
}

int isAVL(struct TreeNode* root) {
    if (root == NULL)
        return 1;

    int balance = getBalanceFactor(root);

    if (abs(balance) <= 1 && isAVL(root->left) && isAVL(root->right))
        return 1;

    return 0;
}

void printRotationCases(struct TreeNode* root, int data) {
    struct TreeNode* newRoot = insertNode(root, data);

    if (isBalanced(newRoot))
        printf("The tree is balanced.\n");
    else {
        printf("The tree is imbalanced.\n");
        int balance = getBalanceFactor(newRoot);
        printf("Balance factor: %d\n", balance);
        if (balance > 1 && data < newRoot->left->data)
            printf("Left-Left rotation needed.\n");
        else if (balance < -1 && data > newRoot->right->data)
            printf("Right-Right rotation needed.\n");
        else if (balance > 1 && data > newRoot->left->data) {
            printf("Left-Right rotation needed.\n");
            printf("Performing Left-Right rotation...\n");
            newRoot->left = leftRotate(newRoot->left);
            newRoot = rightRotate(newRoot);
            printf("Rotation performed.\n");
        } else if (balance < -1 && data < newRoot->right->data) {
            printf("Right-Left rotation needed.\n");
            printf("Performing Right-Left rotation...\n");
            newRoot->right = rightRotate(newRoot->right);
            newRoot = leftRotate(newRoot);
            printf("Rotation performed.\n");
        }
    }
}

void freeTree(struct TreeNode* root) {
    if (root == NULL)
        return;
    freeTree(root->left);
    freeTree(root->right);
    free(root);
}

int main() {
    struct TreeNode* root = NULL;
    int choice, data;

    do {
        printf("\n----- AVL Tree Operations -----\n");
        printf("1. Insert Node\n");
        printf("2. Check if Balanced\n");
        printf("3. Check if AVL\n");
        printf("4. Check Rotation Cases\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter data to insert: ");
                scanf("%d", &data);
                root = insertNode(root, data);
                break;
            case 2:
                if (isBalanced(root))
                    printf("The tree is balanced.\n");
                else
                    printf("The tree is not balanced.\n");
                break;
            case 3:
                if (isAVL(root))
                    printf("The tree is an AVL tree.\n");
                else
                    printf("The tree is not an AVL tree.\n");
                break;
            case 4:
                printf("Enter data to check rotation cases: ");
                scanf("%d", &data);
                printRotationCases(root, data);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    } while (choice != 5);

    
    freeTree(root);

    return 0;
}


------------------------------------------------------------------------------------------------------------------------------------------
representation of graphs using adjacency matrix and adjacency lists
------------------------------------------------------------------------------------------------------------------------------------------
(1) Adjacency Matrix:

Code: 
#include<stdio.h>
#define V 5

void init(int arr[][V])
{
    int i,j;
    for(i = 0; i < V; i++)
        for(j = 0; j < V; j++)
            arr[i][j] = 0;
}

void addEdge(int arr[][V],int src, int dest)
{
     arr[src][dest] = 1;
}

void printAdjMatrix(int arr[][V])
{
     int i, j;

     for(i = 0; i < V; i++)
     {
         for(j = 0; j < V; j++)
         {
             printf("%d ", arr[i][j]);
         }
         printf("\n");
     }
}

int main()
{
    int adjMatrix[V][V];
    int src, dest;

    init(adjMatrix);

    printf("Enter row and column values for each edge (from 0 to %d)\n", V - 1);
    printf("Enter -1 -1 to stop\n");

    while (1) {
        printf("Enter Row(source) and Column(destination): ");
        scanf("%d %d", &src, &dest);

        if (src == -1 || dest == -1)
            break;

        if (src < 0 || src >= V || dest < 0 || dest >= V) {
            printf("Invalid input. Please enter values between 0 and %d\n", V - 1);
            continue;
        }

        addEdge(adjMatrix, src, dest);
    }

    printf("\nAdjacency Matrix:\n");
    printAdjMatrix(adjMatrix);

    return 0;
}

(2) Adjacency Lists:

Code:

#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

int numVertices;
Node** adjacencyList;

Node* createNode(int v) {
    Node* newNode = malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

void initializeGraph(int vertices) {
    numVertices = vertices;
    adjacencyList = malloc(vertices * sizeof(Node*));
    for (int i = 0; i < vertices; i++) {
        adjacencyList[i] = NULL;
    }
}

void addEdge(int src, int dest) {
    Node* newNode = createNode(dest);
    newNode->next = adjacencyList[src];
    adjacencyList[src] = newNode;

    newNode = createNode(src);
    newNode->next = adjacencyList[dest];
    adjacencyList[dest] = newNode;
}

void printGraph() {
    for (int v = 0; v < numVertices; v++) {
        Node* temp = adjacencyList[v];
        printf("Vertex %d:", v);
        while (temp) {
            printf(" -> %d", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    int vertices, src, dest;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    initializeGraph(vertices);

    printf("Enter row and column vertices for each edge (from 0 to %d):\n", vertices - 1);
    printf("Enter -1 -1 to stop.\n");

    while (1) {
        printf("Enter Row(source) and Column(destination): ");
        scanf("%d %d", &src, &dest);

        if (src == -1 || dest == -1)
            break;

        if (src < 0 || src >= vertices || dest < 0 || dest >= vertices) {
            printf("Invalid input. Please enter values between 0 and %d\n", vertices - 1);
            continue;
        }

        addEdge(src, dest);
    }

    printf("\nAdjacency List:\n");
    printGraph();

    return 0;
}


------------------------------------------------------------------------------------------------------------------------------------------
program for graph traversals using BFS and DFS
------------------------------------------------------------------------------------------------------------------------------------------
1.Write a program in C to traverse DFS and BFS on graph using Adjcency matrix. 

CODE:
#include<stdio.h> #include<stdlib.h> #include<stdbool.h> struct node
{
int vertex;
struct node * next;
};
struct stack
{
int d;
struct stack *next;
};
struct stack *top=NULL; struct Queue
{
int data;
struct Queue *next;
};
struct Queue *front =NULL, *rear=NULL; void enqueue(int item)
{
struct Queue * newnode = (struct Queue *)malloc(sizeof(struct Queue)); newnode->data=item;
 
newnode->next=NULL; if(front==NULL)
{
front=rear=newnode;
}
else
{
rear->next=newnode; rear=newnode;
}
}
int dequeue()
{
struct Queue *temp=front; int t=front->data; front=front->next; free(temp);
return t;
}
void push(int item)
{
struct stack * newnode = (struct stack *)malloc(sizeof(struct stack)); newnode->d=item;
newnode->next=top; top=newnode;
}
int pop()
{
if (top == NULL) { printf("Stack underflow\n");
return -1; // or some other error value
 
}
struct stack *temp = top; int t = temp->d;
top = top->next; free(temp); return t;
}
void createAdjMatrix(int adjMatrix[][100],int v)
{
int edges;
for(int i=0; i<v; i++)
{
for(int j=0; j<v; j++)
{
adjMatrix[i][j]=0;
}
}
printf("Enter no. of edges : "); scanf("%d",&edges);
for(int i=0; i<edges; i++)
{
int startvertex,endvertex;
printf("Enter edge (Start vertex & End vertex) : "); scanf("%d %d",&startvertex,&endvertex);
adjMatrix[startvertex][endvertex]=adjMatrix[endvertex][startvertex]=1;
}
}
void adjMatrixBFS(int adjMatrix[][100], int n)
{
int v,visited[n];
 
printf("Enter start vertex : "); scanf("%d",&v);
for(int i=0; i<n; i++)
{
visited[i]=0;
}
visited[v]=1; enqueue(v); while(front!=NULL)
{
v=dequeue(); printf("%d ",v); for(int i=0; i<n; i++)
{
if(adjMatrix[v][i]==1 && visited[i]==0)
{
enqueue(i); visited[i]=1;
}
}
}
}
void adjMatrixDFS(int adjMatrix[][100], int n)
{
int visited[n], v;
for (int i = 0; i < n; i++)
{
visited[i] = 0;
}
printf("Enter start vertex : ");
 
scanf("%d", &v); push(v); visited[v] = 1; printf("%d ", v);
while (top != NULL)
{
v = top->d; int flag = 0;
for (int i = 0; i < n; i++)
{
if (adjMatrix[v][i] == 1 && visited[i] == 0)
{
push(i); printf("%d ", i); visited[i] = 1;
flag = 1; break;
}
}
if (flag == 0)
{
pop();
}
}
}
int main()
{
int n,c;
printf("Enter number of vertices : ");
scanf("%d",&n); struct node *A[n];
int adjMatrix[100][100]; printf("Creation of Adj Matrix :-\n"); createAdjMatrix(adjMatrix,n);
adjMatrixBFS(adjMatrix,n); printf("\n");
adjMatrixDFS(adjMatrix, n); printf("\n");
}

2.Write a program in C to traverse DFS and BFS on graph using Adjcency List.  

CODE :
#include<stdio.h> #include<stdlib.h> #include<stdbool.h>

struct node
{
int vertex;
struct node * next;
};
struct stack
{
int d;
struct stack *next;
};
struct stack *top=NULL;
struct Queue
{
int data;
struct Queue *next;
};
struct Queue *front =NULL, *rear=NULL;
void enqueue(int item)
{
struct Queue * newnode = (struct Queue *)malloc(sizeof(struct Queue)); newnode->data=item;
newnode->next=NULL;
 
if(front==NULL)
{
front=rear=newnode;
}
else
{
rear->next=newnode; rear=newnode;
}
}
int dequeue()
{
struct Queue *temp=front; int t=front->data; front=front->next; free(temp);
return t;
}
void push(int item)
{
struct stack * newnode = (struct stack *)malloc(sizeof(struct stack)); newnode->d=item;
newnode->next=top; top=newnode;
}
int pop()
{
struct stack *temp = top; int t=temp->d; free(temp);
top=top->next; return t;
}
void createAdjList(struct node *A[], int n)
{
int v1,v2; char c;
struct node *p, *temp; for(int i=0; i<n; i++)
{
A[i]=NULL;
}
int edges;
printf("Enter No of edges:"); scanf("%d",&edges);
for(int i=0;i<edges;i++)
{
printf("Enter v1, v2 : ");
scanf("%d %d",&v1,&v2);
temp=(struct node *)malloc(sizeof(struct node)); temp->vertex=v2;
temp->next=NULL; p=A[v1]; if(p==NULL)
{
A[v1]=temp;
}
else
{
while(p->next!=NULL)
 
{
p=p->next;
}
p->next=temp;
}
temp=(struct node *)malloc(sizeof(struct node)); temp->vertex=v1;
temp->next=NULL; p=A[v2]; if(p==NULL)
{
A[v2]=temp;
}
else
{
while(p->next!=NULL)
{
p=p->next;
}
p->next=temp;
}
}
}
void adjListBFS(struct node *A[], int n)
{
int v,visited[10]; struct node *p; for(int i=0; i<n; i++)
{
visited[i]=0;
}
printf("\nEnter start vertex : "); scanf("%d",&v);
enqueue(v); visited[v]=1; while(front!=NULL)
{
v=dequeue(); printf("%d ",v); p=A[v];
while(p!=NULL)
{
if(visited[p->vertex]==0)
{
enqueue(p->vertex); visited[p->vertex]=1;
}
p=p->next;
}
}
}
void adjListDFS(struct node * A[], int n)
{
int visited[n],v; struct node *p; for(int i=0; i<n; i++)
{
visited[i]=0;
}
printf("\nEnter start vertex : ");
 
scanf("%d",&v); push(v); visited[v]=1; printf("%d ",v); do
{
p=A[v];
while(p!=NULL)
{
if(visited[p->vertex]==0)
{
push(p->vertex); v=p->vertex; visited[v]=1; printf("%d ",v); break;
}
else
{
p=p->next;
}
}
if (p == NULL)
{
pop();
if (top != NULL)
{
v = top->d;
}
}
}
while(top!=NULL);
}
int main()
{
int n,c;
printf("Enter number of vertices : "); scanf("%d",&n);
struct node *A[n];
int adjMatrix[100][100]; int ab;
printf("Creation of Adj List :-\n"); createAdjList(A, n);
adjListBFS(A, n); adjListDFS(A, n);
}


------------------------------------------------------------------------------------------------------------------------------------------
demonstrate Hashing using linear or quadratic probing
------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10

void linearProbing(int *hashTable, int size, int key);
void quadraticProbing(int *hashTable, int size, int key);
void printTable(int *hashTable, int size);

void linearProbing(int *hashTable, int size, int key) {
    int index = key % size;
    int originalIndex = index;
    while (hashTable[index] != -1) {
        index = (index + 1) % size;
        if (index == originalIndex) {
            printf("Hash table is full, cannot insert key %d\n", key);
            return;
        }
    }
    hashTable[index] = key;
}

void quadraticProbing(int *hashTable, int size, int key) {
    int index = key % size;
    int i = 1;
    int originalIndex = index;
    while (hashTable[index] != -1) {
        index = (originalIndex + i * i) % size;
        if (index == originalIndex) {
            printf("Hash table is full, cannot insert key %d\n", key);
            return;
        }
        i++;
    }
    hashTable[index] = key;
}

void printTable(int *hashTable, int size) {
    for (int i = 0; i < size; i++) {
        if (hashTable[i] == -1) {
            printf("%d: empty\n", i);
        } else {
            printf("%d: %d\n", i, hashTable[i]);
        }
    }
}

int main() {
    int hashTableLinear[TABLE_SIZE];
    int hashTableQuadratic[TABLE_SIZE];

    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTableLinear[i] = -1;   
        hashTableQuadratic[i] = -1;
    }

    int n;
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int keys[n];
    printf("Enter the elements: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &keys[i]);
    }

    for (int i = 0; i < n; i++) {
        linearProbing(hashTableLinear, TABLE_SIZE, keys[i]);
    }
    for (int i = 0; i < n; i++) {
        quadraticProbing(hashTableQuadratic, TABLE_SIZE, keys[i]);
    }

    printf("Hash Table using Linear Probing:\n");
    printTable(hashTableLinear, TABLE_SIZE);

    printf("\nHash Table using Quadratic Probing:\n");
    printTable(hashTableQuadratic, TABLE_SIZE);

    return 0;
}


------------------------------------------------------------------------------------------------------------------------------------------
to implement Heap data structure. Create Max-heap and insert elements into it.
------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void heapify(int arr[], int N, int i) {
    int largest = i; 
    int l = 2 * i + 1;
    int r = 2 * i + 2; 

    
    if (l < N && arr[l] > arr[largest])
        largest = l;

   
    if (r < N && arr[r] > arr[largest])
        largest = r;

    
    if (largest != i) {
        swap(&arr[i], &arr[largest]);

        heapify(arr, N, largest);
    }
}

void buildHeap(int arr[], int N) {
    int startIdx = (N / 2) - 1;

    for (int i = startIdx; i >= 0; i--) {
        heapify(arr, N, i);
    }
}

int deleteRoot(int arr[], int* N) {
    if (*N <= 0) {
        printf("Heap is empty.\n");
        return -1;
    }

    int root = arr[0];

    
    arr[0] = arr[*N - 1];
    (*N)--; 

    heapify(arr, *N, 0);

    return root;
}
void insert(int arr[], int* N, int key) {
    (*N)++;
    int i = *N - 1;
    arr[i] = key;

    while (i != 0 && arr[(i - 1) / 2] < arr[i]) {
        swap(&arr[i], &arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}
void printHeap(int arr[], int N) {
    printf("Array representation of Heap is:\n");
    for (int i = 0; i < N; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}


int main() {
    int choice, key;
    int arr[100]; 
    int N = 0;    

    while (1) {
        printf("\nMenu:\n");
        printf("1. Insert\n");
        printf("2. Delete\n");
        printf("3. Print Heap\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the value to be inserted: ");
                scanf("%d", &key);
                insert(arr, &N, key);
                printf("Inserted %d into the heap.\n", key);
                break;
            case 2:
                key = deleteRoot(arr, &N);
                if (key != -1) {
                    printf("Deleted root element: %d\n", key);
                }
                break;
            case 3:
                printHeap(arr, N);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice!!.\n");
        }
    }

    return 0;
}


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
